////////////////////////////////////////////////////////////////////////////////
// Copyright Â© 2022 xx foundation                                             //
//                                                                            //
// Use of this source code is governed by a license that can be found in the  //
// LICENSE file.                                                              //
////////////////////////////////////////////////////////////////////////////////

package csprng

import (
	"math/rand"
	"reflect"
	"testing"
)

// Tests that the NewSystemRNG meets the source constructor and returns a valid
// SystemRNG in the interface.
func TestNewSystemRNG(t *testing.T) {

	var sc SourceConstructor

	sc = NewSystemRNG

	csprig := sc()

	_, ok := csprig.(*SystemRNG)
	if !ok {
		t.Errorf("Did not return a SystemRNG pointer under the interface.")
	}
}

// Spot check that the results of the NewSystemRNG vary.
func TestSystemRNG_Read(t *testing.T) {
	csprig := NewSystemRNG()

	src := rand.NewSource(42)
	rng := rand.New(src)

	for i := 0; i < 10; i++ {
		size := rng.Uint32()%10000 + 20
		outputs := make([][]byte, 50)
		for j := range outputs {
			out := make([]byte, size)
			if _, err := csprig.Read(out); err != nil {
				t.Fatalf("Faililed to generate random bytes: %+v", err)
			}
			outputs[j] = out
		}

		for x := 0; x < 50; x++ {
			for y := x + 1; y < 50; y++ {
				if reflect.DeepEqual(outputs[x], outputs[y]) {
					t.Errorf("Two randomly generated byte slices of length %d "+
						"were the same.", size)
				}
			}
		}
	}
}

// Spot check that the SystemRNG.SetSeed does nothing.
func TestSystemRNG_SetSeed(t *testing.T) {
	csprig := NewSystemRNG()

	err := csprig.SetSeed([]byte{})
	if err != nil {
		t.Errorf("SetSeed should never error: %+v", err)
	}
}
